package com.github.jearls.SPRaceTracker.data.importexport;

import java.lang.reflect.Field;
import java.util.Arrays;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.Map;
import java.util.Queue;

import com.github.jearls.SPRaceTracker.data.importexport.FieldInfo.FieldType;

/**
 * This is the base DataObjectExporter class. It analyzes the data store,
 * extracts or creates object data. Subclasses must be defined to do the actual
 * import/export work.
 * 
 * XXX Assumption: All imports and exports are based on strings. This might not
 * be a valid assumption.
 * 
 * @author jearls
 */
public class ClassAnalysis {
    public static final long     serialVersionUID = 1L;

    /**
     * <p>
     * The ClassAnalysis class inspects a data store class to find the public
     * fields that:
     * </p>
     * <ul>
     * <li>are neither static nor final; and</li>
     * <li>are not annotated by:
     * <ul>
     * <li>@Id or</li>
     * <li>@Transient</li>
     * </ul>
     * </li>
     * </ul>
     * <p>
     * For each such field found, it builds a FieldInfo object containing the
     * getter and setter methods for the field and the identity information for
     * the related object this field points to, if any. It puts those FieldInfo
     * objects into two mappings: fieldMap for the data fields and relationMap
     * for the OneToMany and ManyToMany relations. Each such mapping maps a
     * Field to its FieldInfo.
     * </p>
     */

    /**
     * The class against which this analysis was done.
     */
    public Class<?>              objectClass;
    /**
     * The map of Field -> FieldInfo generated by the analysis for the FIELD
     * type fields.
     */
    public Map<Field, FieldInfo> fieldMap         =
                                                          new HashMap<Field, FieldInfo>();
    /**
     * The map of Field -> FieldInfo generated by the analysis for the
     * OWNING_RELATION type fields.
     */
    public Map<Field, FieldInfo> relationMap      =
                                                          new HashMap<Field, FieldInfo>();

    /**
     * Constructs the ClassAnalysis object by finding the non-ignorable fields
     * in the objectClass and building the FieldInfo objects for those fields.
     * This is now a class-protected method; class analysis should be done via
     * the {@link #analyzeClass(Class)} factory method.
     * 
     * @param objectClass
     *            The class to analyze.
     */
    ClassAnalysis(Class<?> objectClass) {
        this.objectClass = objectClass;
        for (Field f : objectClass.getFields()) {
            FieldType fieldType = FieldType.determineFieldType(f);
            if (fieldType != FieldType.IGNORABLE) {
                FieldInfo fieldInfo = new FieldInfo(f);
                if (fieldInfo.getter != null && fieldInfo.setter != null) {
                    if (fieldType == FieldType.FIELD) {
                        fieldMap.put(f, fieldInfo);
                    } else {
                        relationMap.put(f, fieldInfo);
                    }
                }
            }
        }
    }

    @Override
    public String toString() {
        StringBuffer repr =
                new StringBuffer("ClassAnanysis(").append(objectClass).append(
                        ")[");
        repr.append("fieldMap=[");
        {
            String sep = "\n";
            for (FieldInfo fi : fieldMap.values()) {
                repr.append(sep).append(fi.toString());
                sep = ",\n";
            }
        }
        repr.append("\n],relationMap=[");
        {
            String sep = "\n";
            for (FieldInfo fi : relationMap.values()) {
                repr.append(sep).append(fi.toString());
                sep = ",\n";
            }
        }
        return repr.append("\n]]").toString();
    }

    /**
     * the analysis cache for {@link #analyzeClass(Class)}
     */
    static Map<Class<?>, ClassAnalysis> analysisCache =
                                                              new HashMap<Class<?>, ClassAnalysis>();

    /**
     * A caching factory for class analyses. Once analyzed, a class analysis is
     * cached and the cached copy returned on subsequent requests.
     * 
     * @param dataClass
     * @return
     */
    public static ClassAnalysis analyzeClass(Class<?> dataClass) {
        if (!analysisCache.containsKey(dataClass)) {
            analysisCache.put(dataClass, new ClassAnalysis(dataClass));
        }
        return analysisCache.get(dataClass);
    }

    /**
     * Analyze one or more data classes, plus all the classes to which those
     * classes relate through their fields, and return a map of Class -&gt;
     * ClassAnalysis.
     * 
     * @param dataClasses
     *            One or more data classes to analyze.
     * @return A Map of Class -&gt; ClassAnalysis for each listed and related
     *         data class.
     */
    public static Map<Class<?>, ClassAnalysis> analyzeRelatedClasses(Class<?>... dataClasses) {
        Queue<Class<?>> classesToAnalyze =
                new LinkedList<Class<?>>(Arrays.asList(dataClasses));
        Map<Class<?>, ClassAnalysis> relatedClasses =
                new HashMap<Class<?>, ClassAnalysis>();
        while (!classesToAnalyze.isEmpty()) {
            Class<?> dataClass = classesToAnalyze.remove();
            if (!relatedClasses.containsKey(dataClass)) {
                ClassAnalysis analysis = analyzeClass(dataClass);
                relatedClasses.put(dataClass, analysis);
                for (FieldInfo info : analysis.fieldMap.values()) {
                    if (info.relatedObject != null) {
                        classesToAnalyze.add(info.relatedObject.objectClass);
                    }
                }
                for (FieldInfo info : analysis.relationMap.values()) {
                    if (info.relatedObject != null) {
                        classesToAnalyze.add(info.relatedObject.objectClass);
                    }
                }

            }
        }
        return relatedClasses;
    }
}
